{"hash":"8ec2d2d769250ada18e8c764b3b6b292cc183178","data":{"markdownPage":{"id":"bd143580bb9e5be8b60ae8d3b9912596","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)","description":"","path":"/development/oauth2withkeycloak/","timeToRead":4,"content":"<h1 id=\"reqres-방식에서-장애전파-차단---서킷브레이커-new\"><a href=\"#reqres-%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C-%EC%9E%A5%EC%95%A0%EC%A0%84%ED%8C%8C-%EC%B0%A8%EB%8B%A8---%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4-new\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)</h1>\n<h1 id=\"reqres-방식에서-장애전파-차단---서킷브레이커-new-1\"><a href=\"#reqres-%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C-%EC%9E%A5%EC%95%A0%EC%A0%84%ED%8C%8C-%EC%B0%A8%EB%8B%A8---%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4-new-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)</h1>\n<h3 id=\"서킷브레이커를-통하여-장애-전파를-차단\"><a href=\"#%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4%EB%A5%BC-%ED%86%B5%ED%95%98%EC%97%AC-%EC%9E%A5%EC%95%A0-%EC%A0%84%ED%8C%8C%EB%A5%BC-%EC%B0%A8%EB%8B%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서킷브레이커를 통하여 장애 전파를 차단</h3>\n<h4 id=\"이벤트스토밍\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%8A%A4%ED%86%A0%EB%B0%8D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이벤트스토밍</h4>\n<p>서킷브레이커 테스트를 위하여 monolith 에서 order Command 에서 inventory 의 재고량을 조회하는(GET) 호출을 그린다</p>\n<ul>\n<li>order command 에서 Inventory Aggregate 로 선을 연결한다. </li>\n</ul>\n<img width=\"899\" alt=\"image\" src=\"https://user-images.githubusercontent.com/487999/190903135-a6bb95c0-d1f6-424e-9444-1bbf0119386a.png\">\n<ul>\n<li>연결한 선을 더블 클릭하여 호출이름을 다음과 같이 준다: get availability</li>\n<li>호출선의 설정에서 Circuit breaker 옵션을 On 한다</li>\n</ul>\n<img width=\"452\" alt=\"image\" src=\"https://user-images.githubusercontent.com/487999/190903010-1f789fc6-bc4e-4ad5-a7fd-a2a51b11c940.png\">\n<h4 id=\"생성-코드-확인과-구현\"><a href=\"#%EC%83%9D%EC%84%B1-%EC%BD%94%EB%93%9C-%ED%99%95%EC%9D%B8%EA%B3%BC-%EA%B5%AC%ED%98%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>생성 코드 확인과 구현</h4>\n<ul>\n<li>monolith/../Order.java 의 @PrePersist</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">@PrePersist\npublic void onPrePersist() {\n    // Get request from Inventory\n    Inventory inventory =\n        Application.applicationContext.getBean(InventoryService.class)\n        .getInventory(Long.valueOf(getProductId()));\n\n    if(inventory.getStock() &lt; getQty()) throw new RuntimeException(&quot;Out of Stock!&quot;);\n\n}</code></pre>\n<blockquote>\n<p>재고 서비스를 호출한 결과 얻은 재고량을 확인하여 재고가 주문량에 못 미치면 오류를 내도록 하는 검증 로직을 추가</p>\n<ul>\n<li>monolith/../external/InventoryService.java</li>\n</ul>\n</blockquote>\n<pre class=\"language-text\"><code class=\"language-text\">@FeignClient(name = &quot;inventory&quot;, url = &quot;${api.url.inventory}&quot;)\npublic interface InventoryService {\n    @RequestMapping(method = RequestMethod.GET, path = &quot;/inventories/{id}&quot;)\n    public Inventory getInventory(@PathVariable(&quot;id&quot;) Long id);\n\n  ...\n}</code></pre>\n<blockquote>\n<p>재고량을 얻기 위한 GET 호출의 FeignClient Interface 확인</p>\n</blockquote>\n<h4 id=\"서킷브레이커-설정-전-호출\"><a href=\"#%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4-%EC%84%A4%EC%A0%95-%EC%A0%84-%ED%98%B8%EC%B6%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서킷브레이커 설정 전 호출</h4>\n<ul>\n<li>monolith 서비스와 inventory 서비스를 실행한다. </li>\n<li>충분한 재고량을 입력한다</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http :8082/inventories id=1 stock=10000</code></pre>\n<ul>\n<li>부하 툴을 사용하여 동시사용자2명의 10초간의 주문을 넣어본다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">siege -c2 -t10S  -v --content-type &quot;application/json&quot; &#39;http://localhost:8081/orders POST {&quot;productId&quot;:1, &quot;qty&quot;:1}&#39;</code></pre>\n<blockquote>\n<p>siege 툴을 설치하려면 다음 명령으로 설치한다:</p>\n</blockquote>\n<pre class=\"language-text\"><code class=\"language-text\">sudo apt update -y\nsudo apt install siege -y</code></pre>\n<blockquote>\n<p>모든 호출이  201 Code 로 성공함을 알 수 있다.</p>\n</blockquote>\n<h4 id=\"서킷브레이커-설정\"><a href=\"#%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서킷브레이커 설정</h4>\n<ul>\n<li>monolith 서비스의 application.yaml 파일의 다음 설정을 true 로 하고, 임계치를 610ms로 바꾼다:  </li>\n</ul>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">feign</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">hystrix</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n<span class=\"token key atrule\">hystrix</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 전역설정</span>\n    <span class=\"token key atrule\">default</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">execution.isolation.thread.timeoutInMilliseconds</span><span class=\"token punctuation\">:</span> <span class=\"token number\">610</span></code></pre>\n<ul>\n<li>inventory 서비스의 Inventory.java 를 GET 할때 성능이 느려지도록 딜레이 발생 코드를 넣는다.  </li>\n</ul>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostLoad</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">makeDelay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">400</span> <span class=\"token operator\">+</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">220</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>inventory 서비스를 종료하고 재실행한다. </li>\n<li>이때 재고량을 충분히 줘놓아야 한다:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http :8082/inventories id=1 stock=10000</code></pre>\n<ul>\n<li>부하 툴을 사용하여 주문을 넣어본다.  </li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">siege -c2 -t10S  -v --content-type &quot;application/json&quot; &#39;http://localhost:8081/orders POST {&quot;productId&quot;:1, &quot;qty&quot;:1}&#39;</code></pre>\n<blockquote>\n<p>Delay 가 발생함에 따라 적당히 201 code 와 500 오류 코드가 반복되며 inventory 로 부하를 조절하면서 요청을 관리하는 것을 확인할 수 있다.\n결과적으로 Availability 는 60~90% 수준이 유지되면서 서비스는 유지된다.</p>\n</blockquote>\n<ul>\n<li>monolith 서비스의 로그를 확인:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">java.lang.RuntimeException: Hystrix circuit short-circuited and is OPEN</code></pre>\n<blockquote>\n<p>서킷 브레이커가 발동하여 오류가 발생한 것을 확인할 수 있다.</p>\n</blockquote>\n<p>~~ [Tip] 임계치를 바꾸거나 delay 를 바꾸어 가면서 테스트해보세요 ~~</p>\n<h4 id=\"fallback-처리-장애시에-적당한-대체값\"><a href=\"#fallback-%EC%B2%98%EB%A6%AC-%EC%9E%A5%EC%95%A0%EC%8B%9C%EC%97%90-%EC%A0%81%EB%8B%B9%ED%95%9C-%EB%8C%80%EC%B2%B4%EA%B0%92\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>fallback 처리 (장애시에 적당한 대체값)</h4>\n<ul>\n<li>inventory 서비스가 중지된 상태로 주문을 넣어본다. ( 500 에러 )</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http localhost:8081/orders productId=1 qty=1 </code></pre>\n<ul>\n<li>monolith 서비스의 external/InventoryService.java 의 FeignClient에 fallback 옵션을 준다.\n</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">@FeignClient(name = &quot;inventory&quot;, url = &quot;${api.url.inventory}&quot;, fallback = InventoryServiceFallback.class)</code></pre>\n<ul>\n<li>monolith 서비스에 Fallback 구현체를 구현한다:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">package labshopmonolith.external;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class InventoryServiceFallback implements InventoryService{\n    public Inventory getInventory(Long id){\n        Inventory fallbackValue = new Inventory();\n        fallbackValue.setStock(1L);\n\n        return fallbackValue;\n    }\n}</code></pre>\n<ul>\n<li>\n<p>monolith 서비스를 재실행 후 주문을 넣어본다. ( 주문 가능 )</p>\n<ul>\n<li>이때 inventory 서비스는 중지 상태 이어야 한다.  </li>\n<li>InventoryServiceImpl 의 getInventory 메서드가 실행되어 적당한 가짜 값인 1이 리턴되어 재고량이 있는 것으로 리턴하게 하는 것을 확인할 수 있다. </li>\n</ul>\n</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http localhost:8081/orders productId=1 qty=1   # will succeed!</code></pre>\n<ul>\n<li>qty를 1이상인 값으로도 호출해본다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http localhost:8081/orders productId=1 qty=3   # will fail!</code></pre>\n<h4 id=\"다른-circuit-breaker-들\"><a href=\"#%EB%8B%A4%EB%A5%B8-circuit-breaker-%EB%93%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다른 Circuit Breaker 들</h4>\n<p><a href=\"https://dzone.com/articles/comparing-envoy-and-istio-circuit-breaking-with-ne?fbclid=IwAR0wYnXPiAZSVtluJ-17Ywb9dK3xrytAMo3ImIZv8KwoOo2WGGnyTKm6c04\" target=\"_blank\" rel=\"noopener noreferrer\">https://dzone.com/articles/comparing-envoy-and-istio-circuit-breaking-with-ne?fbclid=IwAR0wYnXPiAZSVtluJ-17Ywb9dK3xrytAMo3ImIZv8KwoOo2WGGnyTKm6c04</a></p>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)","anchor":"#reqres-방식에서-장애전파-차단---서킷브레이커-new"},{"depth":1,"value":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)","anchor":"#reqres-방식에서-장애전파-차단---서킷브레이커-new-1"},{"depth":3,"value":"서킷브레이커를 통하여 장애 전파를 차단","anchor":"#서킷브레이커를-통하여-장애-전파를-차단"},{"depth":4,"value":"이벤트스토밍","anchor":"#이벤트스토밍"},{"depth":4,"value":"생성 코드 확인과 구현","anchor":"#생성-코드-확인과-구현"},{"depth":4,"value":"서킷브레이커 설정 전 호출","anchor":"#서킷브레이커-설정-전-호출"},{"depth":4,"value":"서킷브레이커 설정","anchor":"#서킷브레이커-설정"},{"depth":4,"value":"fallback 처리 (장애시에 적당한 대체값)","anchor":"#fallback-처리-장애시에-적당한-대체값"},{"depth":4,"value":"다른 Circuit Breaker 들","anchor":"#다른-circuit-breaker-들"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-service/","title":"12번가 마이크로서비스 라우터(Service) 적용"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-readiness/","title":"무정지 배포 실습"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Commands"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/msa-logging/","title":"MSA 로깅 with EFK Stack"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/development/keycloak-oauth2-2/","title":"Pub/Sub 방식의 연동 (New)"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/development/oauth2withkeycloak/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)"}},{"node":{"path":"/development/keycloak-oauth2-3/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation (New)"}},{"node":{"path":"/development/oauth2/","title":"Req/Res 방식의 MSA 연동 (New)"}},{"node":{"path":"/development/monolith2misvc/","title":"Kafka Retry & Dead Letter Queue (New)"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/gateway/","title":"단위 마이크로 서비스의 실행 (New)"}},{"node":{"path":"/development/kafka-manual-commit/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/keycloak-oauth2-1/","title":"Kafka 기본 명령어 (New)"}},{"node":{"path":"/development/kafka-scaling/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/cna-pubsub/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/kafka-base/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/cna-pubsub2/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/front-end/","title":"Kafka Scaling (New)"}},{"node":{"path":"/development/circuitbreaker/","title":"API Gateway"}},{"node":{"path":"/business/","title":"[분석] DDD 이벤트의 도출 - 12번가 쇼핑몰"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] DDD Food Delivery 예제"}},{"node":{"path":"/development/advanced-connect/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] DDD 구글 드라이브 예제"}}]}},"context":{}}