{"hash":"111274b6c679aae8379740b3dad993eb43961e68","data":{"markdownPage":{"id":"4cf4209d2325d07d12f0b8752dd5411b","title":"JWT Token 기반 인증 인가 - Advanced","description":"","path":"/development/oauth2with-keycloak/","timeToRead":5,"content":"<h1 id=\"jwt-token-기반-인증-인가---advanced\"><a href=\"#jwt-token-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%EC%9D%B8%EA%B0%80---advanced\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT Token 기반 인증 인가 - Advanced</h1>\n<h1 id=\"jwt-token-기반-인증-인가---advanced-1\"><a href=\"#jwt-token-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%EC%9D%B8%EA%B0%80---advanced-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT Token 기반 인증 인가 - Advanced</h1>\n<h2 id=\"jwt기반-인증-w-keycloak\"><a href=\"#jwt%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-w-keycloak\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>JWT기반 인증 w/ Keycloak</h2>\n<h3 id=\"oauth2-stackholders\"><a href=\"#oauth2-stackholders\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>OAuth2 Stackholders</h3>\n<ul>\n<li>Spring Security와 Spring oauth2를 사용하고, Resource Owner, Client, Authorization Server, Resource Server간의 인증/인가를 실습한다.</li>\n<li>JWT기반 Access_Token을 활용한다.</li>\n<li>인증/인가 서버로 Standalone Keycloak(<a href=\"https://www.keycloak.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.keycloak.org/</a>) 서버를 활용한다.</li>\n</ul>\n<h3 id=\"keycloak-sso-토핑-적용\"><a href=\"#keycloak-sso-%ED%86%A0%ED%95%91-%EC%A0%81%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak SSO 토핑 적용</h3>\n<ul>\n<li>Code > Code Preview를 눌러 모델기반 템플릿 코드창을 연다.</li>\n<li>우측 상단의 TOPPINGS를 클릭하여 Keycloak SSO를 적용한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190953029-6f27e3ec-2ad8-4101-b223-6ffe5675af48.png\" alt=\"image\"></li>\n<li>\n<p>적용결과, keycloak 프로젝트가 추가되었고, Client인 Gateway의 application.yml 설정에도 oauth2설정이 추가된 것이 확인된다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190953662-d6b127f8-b532-4cc8-aa42-5b64ea47842f.png\" alt=\"image\"></p>\n<h3 id=\"keycloak-server-접속설정\"><a href=\"#keycloak-server-%EC%A0%91%EC%86%8D%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak Server 접속/설정</h3>\n</li>\n</ul>\n<h4 id=\"keycloak이-적용된-model-code-반영\"><a href=\"#keycloak%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%9C-model-code-%EB%B0%98%EC%98%81\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak이 적용된 Model Code 반영</h4>\n<ul>\n<li>이벤트 스토밍 결과 코드를 생성하고 push 한 후, Code 를 update 한다.</li>\n<li>Gitpod에서 모델코드가 push된 template 브랜치와  main 브랜치를 Merge 한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">git pull &amp;&amp; git merge origin/template</code></pre>\n<h4 id=\"keycloak-서버-실행\"><a href=\"#keycloak-%EC%84%9C%EB%B2%84-%EC%8B%A4%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak 서버 실행</h4>\n<ul>\n<li>keycloak 폴더로 이동하여 컨테이너를 생성하고 및 Keycloak 서버를 실행한다.</li>\n</ul>\n<pre class=\"language-sh\"><code class=\"language-sh\">cd keycloak\ndocker-compose up -d\n# 실행 확인\ndocker container ls </code></pre>\n<h4 id=\"keycloak-서버-오픈-및-접속하기\"><a href=\"#keycloak-%EC%84%9C%EB%B2%84-%EC%98%A4%ED%94%88-%EB%B0%8F-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak 서버 오픈 및 접속하기</h4>\n<ul>\n<li>왼쪽 메뉴의 'Remote Explorer'를 눌러 keycloak이 사용하는 포트(9090)를 외부에 오픈한다.  (자물쇠 아이콘 클릭)\n<img src=\"https://user-images.githubusercontent.com/35618409/190956537-056d6f0a-6b46-45c0-9df8-55d7a3cb7fc4.png\" alt=\"image\"></li>\n<li>오픈된 keycloak 항목 3번째, 브라우저 아이콘(지구모양)을 눌러 웹 브라우저에서 접속한다.  </li>\n<li>Administration Console을 클릭해 설정된 관리자 정보(admin / admin)로 로그인한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190956899-9c7efca3-04ac-4f11-851c-1e199debaa02.png\" alt=\"image\"></li>\n<li>Keycloak 메인 화면이 아래와 같이 출력된다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190957013-3a6669d9-0928-498b-9529-cbac6fad8cd5.png\" alt=\"image\"></li>\n</ul>\n<h3 id=\"keycloak--server와-clientgateway간-security-설정\"><a href=\"#keycloak--server%EC%99%80-clientgateway%EA%B0%84-security-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak  Server와 Client(Gateway)간 Security 설정</h3>\n<ul>\n<li>Master Realm에서 'Tokens' 탭을 눌러 Access Token Lifespan을 1시간으로 수정한다.</li>\n<li>수정 후, 하단의 'save' 를 눌러 저장한다.</li>\n<li>Master Realm에서 Endpoints 링크를 클릭해 엔드포인트 창을 열어둔다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190969570-2a75868c-2b68-44e1-b69c-2bfa4dcfe54b.png\" alt=\"image\"></li>\n</ul>\n<h4 id=\"issuer--등록\"><a href=\"#issuer--%EB%93%B1%EB%A1%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Issuer  등록</h4>\n<ul>\n<li>엔드포인트 창에서 issuer로 검색된 value를 Gateway application.yml에 등록한다.(39라인)\n<img src=\"https://user-images.githubusercontent.com/35618409/190958542-d700f666-f889-49a9-8fde-62fc92267bdc.png\" alt=\"image\"></li>\n</ul>\n<h4 id=\"jwk-uri-등록\"><a href=\"#jwk-uri-%EB%93%B1%EB%A1%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>jwk-uri 등록</h4>\n<ul>\n<li>엔드포인트 창에서 jwk로 검색된 value를 Gateway application.yml에 등록한다.(50라인)\n<img src=\"https://user-images.githubusercontent.com/35618409/190958759-036c3ffd-8fba-42af-905e-a971291557ac.png\" alt=\"image\"></li>\n</ul>\n<h4 id=\"oauth-client-등록\"><a href=\"#oauth-client-%EB%93%B1%EB%A1%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>OAuth Client 등록</h4>\n<ul>\n<li>Keycloak 서버의 왼쪽메뉴에서 Clients를 눌러 12stmall 을 추가한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190959198-145da6e6-f82d-412c-843c-9f5caf47c09e.png\" alt=\"image\"></li>\n<li>등록한 Client id를 Gateway application.yml 설정의 client-id: 에 추가한다.</li>\n<li>등록된 Client 설정에서 Access Type을 confidential로 설정한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190959505-5adf84bf-cda5-4cd9-ba90-e8c7d806a8dc.png\" alt=\"image\"></li>\n<li>아래에 있는 Valid Redirect URIs 설정에 다음과 같이 입력한다.</li>\n<li>규칙 : Gateway Endpoint URL + /login/oauth2/code/ + Client ID(12stmall)\n<img src=\"https://user-images.githubusercontent.com/35618409/191009706-1033fa72-194b-4806-b9e7-33cffcffcf42.png\" alt=\"image\"></li>\n<li>Valid Redirect URIs 정보를 Gateway application.yml 설정의 redirect-uri: 에 추가한다.</li>\n<li>저장 후, Credentials 탭을 확인하면 Secret (비밀번호)가 설정되는데 이를 Gateway application.yml 설정의 client-secret: 에도 추가한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190960454-9348d122-30d3-49b0-b63d-6389107a305e.png\" alt=\"image\">\n</li>\n<li>Application.yml에 완료된 설정은 다음과 같다. (참조)</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">  security:\n    oauth2:\n      client:\n        provider:\n          keycloak:\n            issuer-uri: https://9090-acmexii-labshopmonolith-orw1glcgvae.ws-us65.gitpod.io/realms/master\n            user-name-attribute: preferred_username\n        registration:\n          keycloak:\n            client-id: 12stmall\n            client-secret: 7cic1U8ZS7ZOGruyBNlPY0BHzeeUinXj\n            redirect-uri: https://8088-acmexii-labshopmonolith-orw1glcgvae.ws-us65.gitpod.io/login/oauth2/code/12stmall\n            authorization-grant-type: authorization_code\n            scope: openid\n      resourceserver:\n        jwt:\n          jwk-set-uri: https://9090-acmexii-labshopmonolith-orw1glcgvae.ws-us65.gitpod.io/realms/master/protocol/openid-connect/certs</code></pre>\n<h3 id=\"test-user-등록\"><a href=\"#test-user-%EB%93%B1%EB%A1%9D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Test User 등록</h3>\n<ul>\n<li>Keycloak 서버의 왼쪽 메뉴에서 Users를 눌러 사용자를 등록한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190961205-3c69d45e-2705-4ba2-af18-edbff2f57bf4.png\" alt=\"image\"></li>\n<li>user@naver.com 으로 저장한다.</li>\n<li>등록한 사용자의 Credentials 탭에서 비밀번호를 설정하고,  Temporary를 OFF로 한 다음 설정한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190961449-1acc3c93-f448-42be-8b6e-dd6f4c99ac20.png\" alt=\"image\"></li>\n</ul>\n<h3 id=\"keycloak-sso-test\"><a href=\"#keycloak-sso-test\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Keycloak SSO Test</h3>\n<ul>\n<li>Gateway와 마이크로서비스를  재시작한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">cd gateway\nmvn spring-boot:run</code></pre>\n<ul>\n<li>Gateway 서비스 또한 Liten Port를 외부에 오픈한다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190962087-a82b9e08-0cde-4d28-8e10-05cd89c938ea.png\" alt=\"image\"></li>\n<li>왼쪽 메뉴인 'Remote Explorer'에서도 설정 가능하다.</li>\n<li>마이크로서비스를 시작한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">cd monolith\nmvn spring-boot:run</code></pre>\n<ul>\n<li>다음의 오류 발생시, kafka를 시작한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">Broker may not be available.\n2022-09-19 06:43:53.548  WARN [monolith,,,] 5204 --- [| adminclient-2] org.apache.kafka.clients.NetworkClient   : [AdminClient clientId=adminclient-2] Connection to node -1 (localhost/127.0.0.1:9092) could not be established. Broker may not be available.</code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">cd kafka\ndocker-compose up -d</code></pre>\n<ul>\n<li>웹 브라우저의 새로운 탭에서  Gateway를 경유하여 Order 마이크로서비스에 접속해 본다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">https://8088-acmexii-labshopmonolith-orw1glcgvae.ws-us65.gitpod.io/orders\n(Gateway URL need to be modified)</code></pre>\n<ul>\n<li>비인가된 Resource 접근으로 Keycloak SSO 로그인 창이 나타난다.\n<img src=\"https://user-images.githubusercontent.com/35618409/190966067-a39781e6-87bc-47e6-9688-eea7f7f7cd86.png\" alt=\"image\"></li>\n<li>관리콘솔에서 등록한 사용자(user@naver.com / 1)로 인증한다.</li>\n<li>인증 성공 후, 주문서비스의 응답이 정상적으로 출력된다.</li>\n</ul>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"JWT Token 기반 인증 인가 - Advanced","anchor":"#jwt-token-기반-인증-인가---advanced"},{"depth":1,"value":"JWT Token 기반 인증 인가 - Advanced","anchor":"#jwt-token-기반-인증-인가---advanced-1"},{"depth":2,"value":"JWT기반 인증 w/ Keycloak","anchor":"#jwt기반-인증-w-keycloak"},{"depth":3,"value":"OAuth2 Stackholders","anchor":"#oauth2-stackholders"},{"depth":3,"value":"Keycloak SSO 토핑 적용","anchor":"#keycloak-sso-토핑-적용"},{"depth":3,"value":"Keycloak Server 접속/설정","anchor":"#keycloak-server-접속설정"},{"depth":4,"value":"Keycloak이 적용된 Model Code 반영","anchor":"#keycloak이-적용된-model-code-반영"},{"depth":4,"value":"Keycloak 서버 실행","anchor":"#keycloak-서버-실행"},{"depth":4,"value":"Keycloak 서버 오픈 및 접속하기","anchor":"#keycloak-서버-오픈-및-접속하기"},{"depth":3,"value":"Keycloak  Server와 Client(Gateway)간 Security 설정","anchor":"#keycloak--server와-clientgateway간-security-설정"},{"depth":4,"value":"Issuer  등록","anchor":"#issuer--등록"},{"depth":4,"value":"jwk-uri 등록","anchor":"#jwk-uri-등록"},{"depth":4,"value":"OAuth Client 등록","anchor":"#oauth-client-등록"},{"depth":3,"value":"Test User 등록","anchor":"#test-user-등록"},{"depth":3,"value":"Keycloak SSO Test","anchor":"#keycloak-sso-test"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-readiness/","title":"셀프힐링 & 무정지 배포 실습"}},{"node":{"path":"/operations/ops-service-mesh-istio-2/","title":"[Service Mesh] Istio-2"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/service/","title":"12번가 마이크로서비스 라우터(Service) 생성"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-persistence-volume-efs/","title":"파일공유를 위한 NAS 스토리지 생성과 설정"}},{"node":{"path":"/operations/ops-pod-status/","title":"Pod 상태값에 따른 마이크로서비스 트러블 슈팅"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Command"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/microservice-logging/","title":"마이크로서비스 통합 로깅 with EFK stack"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/development/token-based-auth/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security-to-12st-mall/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/development/pubsub-idempotency/","title":"Pub/Sub 방식의 연동 - Choreography with Idempotency"}},{"node":{"path":"/development/understanding-jpa-based-single-microservice/","title":"마이크로서비스 구현 및 동작원리 이해"}},{"node":{"path":"/development/pub-sub/","title":"Pub/Sub 방식의 연동 "}},{"node":{"path":"/development/pubsub-deadline/","title":"Pub/Sub 방식의 연동 - Choreography with Deadline added"}},{"node":{"path":"/development/ops-docker/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/oauth2with-keycloak/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/monolith-2-misvc/","title":"Req/Res 방식의 MSA 연동 "}},{"node":{"path":"/development/kafka-connect/","title":"CDC(Change Data Capture) with Kafka"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Kafka Retry & Dead Letter Queue "}},{"node":{"path":"/development/kafka-scaling/","title":"Kafka Scaling "}},{"node":{"path":"/development/kafka-basic/","title":"Kafka 기본 명령어 "}},{"node":{"path":"/development/gateway/","title":"API Gateway"}},{"node":{"path":"/development/dp-graphql/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/dp-frontend/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/business/","title":"[이벤트스토밍] - 12번가 쇼핑몰 예제"}},{"node":{"path":"/development/dp-cqrs/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/contract-test/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/development/cna-start/","title":"단위 마이크로 서비스의 실행 "}},{"node":{"path":"/development/circuit-breaker/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 "}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] - DDD Food Delivery 예제"}},{"node":{"path":"/development/compensation-correlation/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] - 구글 드라이브 예제"}}]}},"context":{}}