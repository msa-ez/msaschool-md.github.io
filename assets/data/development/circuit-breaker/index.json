{"hash":"111274b6c679aae8379740b3dad993eb43961e68","data":{"markdownPage":{"id":"071d9ce035abd9bda9236f972c2dda45","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 ","description":"","path":"/development/circuit-breaker/","timeToRead":4,"content":"<h1 id=\"reqres-방식에서-장애전파-차단---서킷브레이커\"><a href=\"#reqres-%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C-%EC%9E%A5%EC%95%A0%EC%A0%84%ED%8C%8C-%EC%B0%A8%EB%8B%A8---%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Req/Res 방식에서 장애전파 차단 - 서킷브레이커</h1>\n<h1 id=\"reqres-방식에서-장애전파-차단---서킷브레이커-1\"><a href=\"#reqres-%EB%B0%A9%EC%8B%9D%EC%97%90%EC%84%9C-%EC%9E%A5%EC%95%A0%EC%A0%84%ED%8C%8C-%EC%B0%A8%EB%8B%A8---%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Req/Res 방식에서 장애전파 차단 - 서킷브레이커</h1>\n<h3 id=\"서킷브레이커를-통하여-장애-전파를-차단\"><a href=\"#%EC%84%9C%ED%82%B7%EB%B8%8C%EB%A0%88%EC%9D%B4%EC%BB%A4%EB%A5%BC-%ED%86%B5%ED%95%98%EC%97%AC-%EC%9E%A5%EC%95%A0-%EC%A0%84%ED%8C%8C%EB%A5%BC-%EC%B0%A8%EB%8B%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>서킷브레이커를 통하여 장애 전파를 차단</h3>\n<h4 id=\"이벤트스토밍\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%8A%A4%ED%86%A0%EB%B0%8D\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>이벤트스토밍</h4>\n<p>서킷브레이커 테스트를 위하여 Order의 order Command 에서 inventory 의 재고량을 조회하는(GET) 호출을 그린다</p>\n<ul>\n<li>order command 에서 Inventory Aggregate 로 선을 연결한다. </li>\n</ul>\n<img width=\"899\" alt=\"image\" src=\"https://user-images.githubusercontent.com/487999/190903135-a6bb95c0-d1f6-424e-9444-1bbf0119386a.png\">\n<ul>\n<li>연결한 선을 더블 클릭하여 호출이름을 다음과 같이 준다: get availability</li>\n<li>호출선의 설정에서 Circuit breaker 옵션을 On 한다</li>\n</ul>\n<img width=\"452\" alt=\"image\" src=\"https://user-images.githubusercontent.com/487999/190903010-1f789fc6-bc4e-4ad5-a7fd-a2a51b11c940.png\">\n<h4 id=\"생성-코드-확인과-구현\"><a href=\"#%EC%83%9D%EC%84%B1-%EC%BD%94%EB%93%9C-%ED%99%95%EC%9D%B8%EA%B3%BC-%EA%B5%AC%ED%98%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>생성 코드 확인과 구현</h4>\n<ul>\n<li>monolith/../Order.java 의 @PrePersist</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">    @PrePersist\n    public void onPrePersist() {\n        // Get request from Inventory\n        Inventory inventory =\n           Application.applicationContext.getBean(InventoryService.class)\n           .getInventory(Long.valueOf(getProductId()));\n\n        if(inventory.getStock() &lt; getQty()) throw new RuntimeException(&quot;Out of Stock!&quot;);\n\n    }</code></pre>\n<blockquote>\n<p>재고 서비스를 호출한 결과 얻은 재고량을 확인하여 재고가 주문량에 못 미치면 오류를 내도록 하는 검증 로직을 추가</p>\n<ul>\n<li>monolith/../external/InventoryService.java</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"></code></pre>\n</blockquote>\n<p>@FeignClient(name = \"inventory\", url = \"${api.url.inventory}\")\npublic interface InventoryService {\n@RequestMapping(method = RequestMethod.GET, path = \"/inventories/{id}\")\npublic Inventory getInventory(@PathVariable(\"id\") Long id);</p>\n<p>  ...\n}</p>\n<pre class=\"language-text\"><code class=\"language-text\">&gt; 재고량을 얻기 위한 GET 호출의 FeignClient Interface 확인\n\n\n\n#### 서킷브레이커 설정 전 호출 \n- monolith(Order) 서비스와 inventory 서비스를 실행한다. \n- 충분한 재고량을 입력한다</code></pre>\n<p>http :8082/inventories id=1 stock=10000</p>\n<pre class=\"language-text\"><code class=\"language-text\">- 부하 툴을 사용하여 동시사용자 2명의 10초간의 주문을 넣어본다.\n    ```\n    siege -c2 -t10S  -v --content-type &quot;application/json&quot; &#39;http://localhost:8081/orders POST {&quot;productId&quot;:1, &quot;qty&quot;:1}&#39;\n    ```\n&gt; siege 툴을 설치하려면 다음 명령으로 설치한다:</code></pre>\n<p>sudo apt update -y\nsudo apt install siege -y</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t\t\n&gt; 모든 호출이  201 Code 로 성공함을 알 수 있다.\n\n#### 서킷브레이커 설정\n\n- monolith(Order) 서비스의 application.yaml 파일의 다음 설정을 true 로 하고, 임계치를 610ms로 바꾼다:  \n\n    ````yaml\n  \n    feign:\n      hystrix:\n        enabled: true\n    \n    hystrix:\n      command:\n        # 전역설정\n        default:\n          execution.isolation.thread.timeoutInMilliseconds: 610\n    ````\n\n- inventory 서비스의 Inventory.java 를 GET 할때 성능이 느려지도록 딜레이 발생 코드를 넣는다.  \n\n\n   ````java\n    @PostLoad\n    public void makeDelay(){\n        try {\n            Thread.currentThread().sleep((long) (400 + Math.random() * 220));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }</code></pre>\n<ul>\n<li>inventory 서비스를 종료하고 재실행한다. </li>\n<li>이때 재고량을 충분히 줘놓아야 한다:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http :8082/inventories id=1 stock=10000</code></pre>\n<ul>\n<li>\n<p>부하 툴을 사용하여 주문을 넣어본다.  </p>\n<pre class=\"language-text\"><code class=\"language-text\">```\nsiege -c2 -t10S  -v --content-type &quot;application/json&quot; &#39;http://localhost:8081/orders POST {&quot;productId&quot;:1, &quot;qty&quot;:1}&#39;\n```</code></pre>\n<blockquote>\n<p>Delay 가 발생함에 따라 적당히 201 code 와 500 오류 코드가 반복되며 inventory 로 부하를 조절하면서 요청을 관리하는 것을 확인할 수 있다.\n결과적으로 Availability 는 60~90% 수준이 유지되면서 서비스는 유지된다.</p>\n</blockquote>\n</li>\n<li>monolith(Order) 서비스의 로그를 확인:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">java.lang.RuntimeException: Hystrix circuit short-circuited and is OPEN</code></pre>\n<blockquote>\n<p>서킷 브레이커가 발동하여 오류가 발생한 것을 확인할 수 있다.</p>\n</blockquote>\n<p>~~ [Tip] 임계치를 바꾸거나 delay 를 바꾸어 가면서 테스트해보세요 ~~</p>\n<h4 id=\"fallback-처리-장애시에-적당한-대체값\"><a href=\"#fallback-%EC%B2%98%EB%A6%AC-%EC%9E%A5%EC%95%A0%EC%8B%9C%EC%97%90-%EC%A0%81%EB%8B%B9%ED%95%9C-%EB%8C%80%EC%B2%B4%EA%B0%92\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>fallback 처리 (장애시에 적당한 대체값)</h4>\n<ul>\n<li>inventory 서비스가 중지된 상태로 주문을 넣어본다. ( 500 에러 )</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http localhost:8081/orders productId=1 qty=1 </code></pre>\n<ul>\n<li>\n<p>monolith 서비스의 external/InventoryService.java 의 FeignClient에 fallback 옵션을 준다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">@FeignClient(name = &quot;inventory&quot;, url = &quot;${api.url.inventory}&quot;, fallback = InventoryServiceFallback.class)</code></pre>\n</li>\n<li>monolith(Order) 서비스에 Fallback 구현체를 구현한다:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">package labshoppubsub.external;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class InventoryServiceFallback implements InventoryService{\n    public Inventory getInventory(Long id){\n        Inventory fallbackValue = new Inventory();\n        fallbackValue.setStock(1L);\n\n        return fallbackValue;\n    }\n}</code></pre>\n<ul>\n<li>\n<p>monolith(Order) 서비스를 재실행 후 주문을 넣어본다. ( 주문 가능 )</p>\n<ul>\n<li>이때 inventory 서비스는 중지 상태 이어야 한다.  </li>\n<li>InventoryServiceImpl 의 getInventory 메서드가 실행되어 적당한 가짜 값인 1이 리턴되어 재고량이 있는 것으로 리턴하게 하는 것을 확인할 수 있다. </li>\n</ul>\n</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http localhost:8081/orders productId=1 qty=1   # will succeed!</code></pre>\n<ul>\n<li>qty를 1이상인 값으로도 호출해본다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http localhost:8081/orders productId=1 qty=3   # will fail!</code></pre>\n<h4 id=\"다른-circuit-breaker-들\"><a href=\"#%EB%8B%A4%EB%A5%B8-circuit-breaker-%EB%93%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>다른 Circuit Breaker 들</h4>\n<p><a href=\"https://dzone.com/articles/comparing-envoy-and-istio-circuit-breaking-with-ne?fbclid=IwAR0wYnXPiAZSVtluJ-17Ywb9dK3xrytAMo3ImIZv8KwoOo2WGGnyTKm6c04\" target=\"_blank\" rel=\"noopener noreferrer\">https://dzone.com/articles/comparing-envoy-and-istio-circuit-breaking-with-ne?fbclid=IwAR0wYnXPiAZSVtluJ-17Ywb9dK3xrytAMo3ImIZv8KwoOo2WGGnyTKm6c04</a></p>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커","anchor":"#reqres-방식에서-장애전파-차단---서킷브레이커"},{"depth":1,"value":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커","anchor":"#reqres-방식에서-장애전파-차단---서킷브레이커-1"},{"depth":3,"value":"서킷브레이커를 통하여 장애 전파를 차단","anchor":"#서킷브레이커를-통하여-장애-전파를-차단"},{"depth":4,"value":"이벤트스토밍","anchor":"#이벤트스토밍"},{"depth":4,"value":"생성 코드 확인과 구현","anchor":"#생성-코드-확인과-구현"},{"depth":4,"value":"fallback 처리 (장애시에 적당한 대체값)","anchor":"#fallback-처리-장애시에-적당한-대체값"},{"depth":4,"value":"다른 Circuit Breaker 들","anchor":"#다른-circuit-breaker-들"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-readiness/","title":"셀프힐링 & 무정지 배포 실습"}},{"node":{"path":"/operations/ops-service-mesh-istio-2/","title":"[Service Mesh] Istio-2"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/service/","title":"12번가 마이크로서비스 라우터(Service) 생성"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-persistence-volume-efs/","title":"파일공유를 위한 NAS 스토리지 생성과 설정"}},{"node":{"path":"/operations/ops-pod-status/","title":"Pod 상태값에 따른 마이크로서비스 트러블 슈팅"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Command"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/microservice-logging/","title":"마이크로서비스 통합 로깅 with EFK stack"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/development/token-based-auth/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security-to-12st-mall/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/development/pubsub-idempotency/","title":"Pub/Sub 방식의 연동 - Choreography with Idempotency"}},{"node":{"path":"/development/understanding-jpa-based-single-microservice/","title":"마이크로서비스 구현 및 동작원리 이해"}},{"node":{"path":"/development/pub-sub/","title":"Pub/Sub 방식의 연동 "}},{"node":{"path":"/development/pubsub-deadline/","title":"Pub/Sub 방식의 연동 - Choreography with Deadline added"}},{"node":{"path":"/development/ops-docker/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/oauth2with-keycloak/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/monolith-2-misvc/","title":"Req/Res 방식의 MSA 연동 "}},{"node":{"path":"/development/kafka-connect/","title":"CDC(Change Data Capture) with Kafka"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Kafka Retry & Dead Letter Queue "}},{"node":{"path":"/development/kafka-scaling/","title":"Kafka Scaling "}},{"node":{"path":"/development/kafka-basic/","title":"Kafka 기본 명령어 "}},{"node":{"path":"/development/gateway/","title":"API Gateway"}},{"node":{"path":"/development/dp-graphql/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/dp-frontend/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/business/","title":"[이벤트스토밍] - 12번가 쇼핑몰 예제"}},{"node":{"path":"/development/dp-cqrs/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/contract-test/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/development/cna-start/","title":"단위 마이크로 서비스의 실행 "}},{"node":{"path":"/development/circuit-breaker/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 "}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] - DDD Food Delivery 예제"}},{"node":{"path":"/development/compensation-correlation/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] - 구글 드라이브 예제"}}]}},"context":{}}