{"hash":"8ec2d2d769250ada18e8c764b3b6b292cc183178","data":{"markdownPage":{"id":"f9c12ef50d515a13f97a31a4e3f34578","title":"셀프힐링 실습","description":"","path":"/operations/ops-liveness/","timeToRead":3,"content":"<h1 id=\"셀프힐링-실습\"><a href=\"#%EC%85%80%ED%94%84%ED%9E%90%EB%A7%81-%EC%8B%A4%EC%8A%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>셀프힐링 실습</h1>\n<h1 id=\"셀프힐링-실습-1\"><a href=\"#%EC%85%80%ED%94%84%ED%9E%90%EB%A7%81-%EC%8B%A4%EC%8A%B5-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>셀프힐링 실습</h1>\n<h3 id=\"셀프힐링-실습-livenessprobe-설정\"><a href=\"#%EC%85%80%ED%94%84%ED%9E%90%EB%A7%81-%EC%8B%A4%EC%8A%B5-livenessprobe-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>셀프힐링 실습 (livenessProbe 설정)</h3>\n<p>Pod는 정상적으로 작동하지만 내부의 어플리케이션이 반응이 없다면, 컨테이너는 의미가 없다.<br>\n위와 같은 경우는 어플리케이션의 Deadlock 또는 메모리 과부화로 인해 발생할 수 있으며, 발생했을 경우 컨테이너를 다시 시작해야 한다.<br>\nLiveness probe는 Pod의 상태를 체크하다가, Pod의 상태가 비정상인 경우 kubelet을 통해서 재시작한다.  </p>\n<p>이번시간에는 특정 API 를 호출시 어플리케이션의 메모리 과부화를 발생시켜 서비스가 동작안하는 상황을 만든다.<br>\n그 후 livenessProbe 설정에 의하여 자동으로 서비스가 재시작 되는 실습을 한다.</p>\n<h3 id=\"선행과정\"><a href=\"#%EC%84%A0%ED%96%89%EA%B3%BC%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>선행과정</h3>\n<ul>\n<li>메모리 릭을 유도하는 소스코드의 확인: shopmall/order/src/main/java/shopmall/OrderController.java</li>\n<li>mvn 패키징을 통해서 애플리케이션을jar파일로 압축한다:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"> mvn package -B</code></pre>\n<ul>\n<li>애플리케이션을 도커허브나 플랫폼별 컨테이너 레지스트리에 <strong>order:memleak</strong>의 이름으로 push 한다\ne.g. ACR case:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">az acr build --registry user27 --image user27.azurecr.io/order:memleak .</code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">- shopmall &gt; order &gt; kubernetes 폴더로 이동하여 deployment.yaml 파일을 수정한다.\n- 19 Line 의 이미지명 부분을 생성한 이미지명으로 변경한다.\n- cd /home/project/ops-deploy-my-app/shopmall/order/kubernetes\n- kubectl apply -f deployment.yml\n- kubectl apply -f service.yaml\n\n- kubectl get po 실행하여 STATUS가 정상적으로 Running 상태 확인</code></pre>\n<h3 id=\"1-livenessprobe-확인\"><a href=\"#1-livenessprobe-%ED%99%95%EC%9D%B8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. livenessProbe 확인</h3>\n<p>1.1 터미널을 열어서 siege Pod 로 들어간 후 http 명령으로 주문서비스를 호출하여 정상작동하는지 확인한다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl exec -it siege -- /bin/bash\nhttp http://order:8080/orders\t</code></pre>\n<p>1.2 새로운 터미널을 열어서 Pod 의 변화를 살펴보기 위하여 watch 를 걸어놓는다</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get po -w</code></pre>\n<p>1.3 order 서비스의 OrderController.java 코드를 살펴보면 메모리를 강제로 부하시키는 코드를 호출한다. (callMemleak 호출)</p>\n<pre class=\"language-text\"><code class=\"language-text\">http http://order:8080/callMemleak</code></pre>\n<p>1.4 watch 걸어놓은 pod 에서 pod 의 상태를 확인한다.</p>\n<ul>\n<li>RESTARTS 카운트가 증가하는 것을 확인 한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">root@labs--201094368:~# kubectl get po -w\nNAME                     READY   STATUS    RESTARTS   AGE\norder-684647ccf9-ltlqg   1/1     Running   0          80s\nsiege                    1/1     Running   0          2m9s\norder-684647ccf9-ltlqg   0/1     OOMKilled   0          116s\norder-684647ccf9-ltlqg   0/1     Running     1          119s\norder-684647ccf9-ltlqg   1/1     Running     1          2m17s</code></pre>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"셀프힐링 실습","anchor":"#셀프힐링-실습"},{"depth":1,"value":"셀프힐링 실습","anchor":"#셀프힐링-실습-1"},{"depth":3,"value":"셀프힐링 실습 (livenessProbe 설정)","anchor":"#셀프힐링-실습-livenessprobe-설정"},{"depth":3,"value":"선행과정","anchor":"#선행과정"},{"depth":3,"value":"1. livenessProbe 확인","anchor":"#1-livenessprobe-확인"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-service/","title":"12번가 마이크로서비스 라우터(Service) 적용"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-readiness/","title":"무정지 배포 실습"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Commands"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/msa-logging/","title":"MSA 로깅 with EFK Stack"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/development/keycloak-oauth2-2/","title":"Pub/Sub 방식의 연동 (New)"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/development/oauth2withkeycloak/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)"}},{"node":{"path":"/development/keycloak-oauth2-3/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation (New)"}},{"node":{"path":"/development/oauth2/","title":"Req/Res 방식의 MSA 연동 (New)"}},{"node":{"path":"/development/monolith2misvc/","title":"Kafka Retry & Dead Letter Queue (New)"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/gateway/","title":"단위 마이크로 서비스의 실행 (New)"}},{"node":{"path":"/development/kafka-manual-commit/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/keycloak-oauth2-1/","title":"Kafka 기본 명령어 (New)"}},{"node":{"path":"/development/kafka-scaling/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/cna-pubsub/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/kafka-base/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/cna-pubsub2/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/front-end/","title":"Kafka Scaling (New)"}},{"node":{"path":"/development/circuitbreaker/","title":"API Gateway"}},{"node":{"path":"/business/","title":"[분석] DDD 이벤트의 도출 - 12번가 쇼핑몰"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] DDD Food Delivery 예제"}},{"node":{"path":"/development/advanced-connect/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] DDD 구글 드라이브 예제"}}]}},"context":{}}