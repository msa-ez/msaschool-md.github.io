{"hash":"8ec2d2d769250ada18e8c764b3b6b292cc183178","data":{"markdownPage":{"id":"01c10ec9eaf16edfe90101161e095ff2","title":"12번가 마이크로서비스 라우터(Service) 적용","description":"","path":"/operations/ops-service/","timeToRead":3,"content":"<h1 id=\"12번가-마이크로서비스-라우터service-적용\"><a href=\"#12%EB%B2%88%EA%B0%80-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%9D%BC%EC%9A%B0%ED%84%B0service-%EC%A0%81%EC%9A%A9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>12번가 마이크로서비스 라우터(Service) 적용</h1>\n<h1 id=\"12번가-마이크로서비스-라우터service-적용-1\"><a href=\"#12%EB%B2%88%EA%B0%80-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%9D%BC%EC%9A%B0%ED%84%B0service-%EC%A0%81%EC%9A%A9-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>12번가 마이크로서비스 라우터(Service) 적용</h1>\n<h3 id=\"the-route-for-containers--service\"><a href=\"#the-route-for-containers--service\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Route for Containers : Service</h3>\n<ul>\n<li>마이크로서비스들의 라우터인 Serivce Scope에 대해 실습한다.</li>\n<li>외부에서 마이크로서비스까지 요청이 전달되는 과정에 Kube Proxy의 역할에 대해 이해한다.</li>\n</ul>\n<h3 id=\"service-basic-template\"><a href=\"#service-basic-template\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Service basic template</h3>\n<pre class=\"language-text\"><code class=\"language-text\">  apiVersion: v1\n  kind: Service\n  metadata:\n    name: my-service\n  spec:\n    selector:\n      app: order\n    ports:\n      - protocol: TCP\n        port: 8080\n        targetPort: 8080\n    type: ClusterIP/NodePort/LoadBalancer\t\t</code></pre>\n<h3 id=\"대상-컨테이너-생성\"><a href=\"#%EB%8C%80%EC%83%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>대상 컨테이너 생성</h3>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl create deploy order --image=ghcr.io/acmexii/order-liveness:latest            </code></pre>\n<h3 id=\"clusterip-type-service-생성\"><a href=\"#clusterip-type-service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ClusterIP Type Service 생성</h3>\n<ul>\n<li>클러스터 내에서만 접근 가능한 라우터를 생성한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl expose deploy order --type=ClusterIP --port=8080 --target-port=8080\n# 생성된 ClusterIP 정보확인\nkubectl get service \n# Selector 확인\nkubectl get service order -o yaml</code></pre>\n<ul>\n<li>새로운 Terminal에서 클라이언트용 컨테이너를 생성하고 접속한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: siege\nspec:\n  containers:\n  - name: siege\n    image: apexacme/siege-nginx\nEOF</code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl exec -it siege -- /bin/bash</code></pre>\n<ul>\n<li>위에서 확인된 Order 서비스의 ClusterIP로  접근한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">http http://10.x.x.x:8080</code></pre>\n<h3 id=\"nodeport-type-service-생성\"><a href=\"#nodeport-type-service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>NodePort Type Service 생성</h3>\n<ul>\n<li>워크 노드의 포트를 통해서도 접근 가능한 라우터를 다시 생성한다.  </li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete service order\nkubectl expose deploy order --type=NodePort --port=8080 --target-port=8080\n# 생성된 NodePort 정보확인\nkubectl get service </code></pre>\n<ul>\n<li>NodePort로 서비스 접근</li>\n<li>Order 컨테이너가 바인딩 된 Worker-Node를 확인한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get pod -o wide</code></pre>\n<ul>\n<li>해당 워크노드의 Cluster IP를 통해 접근한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># Worker-Node IP 확인\nkubectl get nodes -o wide\n# siege 터미널에서 NodePort 접속\nhttp http://192.168.x.x:3xxxx</code></pre>\n<ul>\n<li>Order Pod가 바인딩 되지않은 다른 Worker-Node를 통해서도 접근해 본다.</li>\n<li>접근이 된다, 이유는</li>\n<li>라우터 생성시 모든 Node상에 있는 Kube-proxy Daemon이 Networking Rule 작업(Iptables 갱신)을 수행하므로 어느 Node로 접속해도 접근 가능하다. </li>\n<li>Rule 확인하기</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># AWS Console을 통해 EC2 &gt; Auto Scaling Group &gt; Work-Node에 SSH로 접근\n$ iptables -t nat -S | grep 8080</code></pre>\n<h3 id=\"loadbalancer-type-service-생성\"><a href=\"#loadbalancer-type-service-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>LoadBalancer Type Service 생성</h3>\n<ul>\n<li>워크 노드의 포트 뿐만 아니라 클라우드 외부에서도 접근 가능한 라우터를 다시 생성한다.  </li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete service order\nkubectl expose deploy order --type=LoadBalancer --port=8080 --target-port=8080\n# 생성된 LoadBalancer 정보확인\nkubectl get service</code></pre>\n<ul>\n<li>LoadBalancer 엔드포인트로 서비스 접근</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># Order Service의 External-IP 복사   \n# Web Browser를 통한 접속</code></pre>\n<h3 id=\"kube-dns-a레코드를-통한-접근\"><a href=\"#kube-dns-a%EB%A0%88%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%A0%91%EA%B7%BC\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Kube-DNS A레코드를 통한 접근</h3>\n<pre class=\"language-text\"><code class=\"language-text\"># siege 터미널에서\nhttp http://order:8080</code></pre>\n<ul>\n<li>Kubernetes Cluster에서 서비스가 생성되면 Kube-DNS에 A레코드가 등록되고, 서비스가 삭제되면 A레코드 또한 자동 삭제한다.</li>\n<li>Kube-DNS 정보확인</li>\n<li>kubectl get service -n kube-system</li>\n<li>kubernetes는 컨테이너 생성시에 NameServer(Kube-DNS) 정보를 자동 Injection 한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">$ cat /etc/resolv.conf</code></pre>\n<ul>\n<li>마이크로서비스간 참조시, Service ClusterIP 또한 유동적이므로 Cluster 내에서는 '서비스 이름'으로 접근한다.</li>\n</ul>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"12번가 마이크로서비스 라우터(Service) 적용","anchor":"#12번가-마이크로서비스-라우터service-적용"},{"depth":1,"value":"12번가 마이크로서비스 라우터(Service) 적용","anchor":"#12번가-마이크로서비스-라우터service-적용-1"},{"depth":3,"value":"The Route for Containers : Service","anchor":"#the-route-for-containers--service"},{"depth":3,"value":"Service basic template","anchor":"#service-basic-template"},{"depth":3,"value":"대상 컨테이너 생성","anchor":"#대상-컨테이너-생성"},{"depth":3,"value":"ClusterIP Type Service 생성","anchor":"#clusterip-type-service-생성"},{"depth":3,"value":"NodePort Type Service 생성","anchor":"#nodeport-type-service-생성"},{"depth":3,"value":"LoadBalancer Type Service 생성","anchor":"#loadbalancer-type-service-생성"},{"depth":3,"value":"Kube-DNS A레코드를 통한 접근","anchor":"#kube-dns-a레코드를-통한-접근"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-service/","title":"12번가 마이크로서비스 라우터(Service) 적용"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-readiness/","title":"무정지 배포 실습"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Commands"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/msa-logging/","title":"MSA 로깅 with EFK Stack"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/development/keycloak-oauth2-2/","title":"Pub/Sub 방식의 연동 (New)"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/development/oauth2withkeycloak/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)"}},{"node":{"path":"/development/keycloak-oauth2-3/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation (New)"}},{"node":{"path":"/development/oauth2/","title":"Req/Res 방식의 MSA 연동 (New)"}},{"node":{"path":"/development/monolith2misvc/","title":"Kafka Retry & Dead Letter Queue (New)"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/gateway/","title":"단위 마이크로 서비스의 실행 (New)"}},{"node":{"path":"/development/kafka-manual-commit/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/keycloak-oauth2-1/","title":"Kafka 기본 명령어 (New)"}},{"node":{"path":"/development/kafka-scaling/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/cna-pubsub/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/kafka-base/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/cna-pubsub2/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/front-end/","title":"Kafka Scaling (New)"}},{"node":{"path":"/development/circuitbreaker/","title":"API Gateway"}},{"node":{"path":"/business/","title":"[분석] DDD 이벤트의 도출 - 12번가 쇼핑몰"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] DDD Food Delivery 예제"}},{"node":{"path":"/development/advanced-connect/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] DDD 구글 드라이브 예제"}}]}},"context":{}}