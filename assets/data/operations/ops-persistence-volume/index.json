{"hash":"8ec2d2d769250ada18e8c764b3b6b292cc183178","data":{"markdownPage":{"id":"f760f3707a304534f0c61aa304e68776","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정","description":"","path":"/operations/ops-persistence-volume/","timeToRead":10,"content":"<h1 id=\"파일시스템-볼륨-연결과-데이터베이스-설정\"><a href=\"#%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B3%BC%EB%A5%A8-%EC%97%B0%EA%B2%B0%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>파일시스템 (볼륨) 연결과 데이터베이스 설정</h1>\n<h2 id=\"주문-서비스에-database-설정의-변경\"><a href=\"#%EC%A3%BC%EB%AC%B8-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-database-%EC%84%A4%EC%A0%95%EC%9D%98-%EB%B3%80%EA%B2%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>주문 서비스에 Database 설정의 변경</h2>\n<blockquote>\n<p>데이터베이스 설정이 이루어진 order project 를 다운로드 받는다</p>\n</blockquote>\n<pre class=\"language-text\"><code class=\"language-text\">cd ~\ngit clone https://github.com/event-storming/monolith\n\ncd monolith</code></pre>\n<p>Dockerfile-prod 를 Dockerfile 로 바꾼다.\n기존 Dockerfile 삭제.</p>\n<pre class=\"language-text\"><code class=\"language-text\">rm Dockerfile\nmv Dockerfile-prod Dockerfile</code></pre>\n<p>빌드하여 order:database 라는 이미지명으로 레지스트리에 등록한다\ne.g. (도커허브경우)</p>\n<pre class=\"language-text\"><code class=\"language-text\">mvn package -B \n\n# docker hub 경우\ndocker build -t jinyoung/order:database .\n\n# azure 의 경우\naz acr build --registry user27 --image user27.azurecr.io/order:database .</code></pre>\n<blockquote>\n<p>왼쪽 에디터에서 생성된 프로젝트를 열기위해서는, Explorer 의 바의 우측 ... 버튼을 클릭한후, Add folder to workspace 를 클릭한후, 다운받은 monolith 를 선택한다.</p>\n</blockquote>\n<p>order 서비스의 Database 설정을 아래와 같이 변경하므로써, 외부의 데이터베이스에 접근 가능하게 된다:</p>\n<p>application.yml (or application-prod.yml)</p>\n<pre class=\"language-text\"><code class=\"language-text\">spring:\n  jpa:\n    hibernate:\n      naming:\n        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n      ddl-auto: update\n    properties:\n      hibernate:\n        show_sql: true\n        format_sql: true\n        dialect: org.hibernate.dialect.MySQL57Dialect\n  datasource:\n    url: jdbc:mysql://${_DATASOURCE_ADDRESS:35.221.110.118:3306}/${_DATASOURCE_TABLESPACE:my-database}\n    username: ${_DATASOURCE_USERNAME:root1}\n    password: ${_DATASOURCE_PASSWORD:secretpassword}\n    driverClassName: com.mysql.cj.jdbc.Driver</code></pre>\n<p>변경한 정보를 환경변수에서 얻어오도록 설정하였고,  Deployment 에서 위의 값이 전달되도록 주입할 수 있다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: &quot;apps/v1&quot;\nkind: &quot;Deployment&quot;\nmetadata: \n  name: &quot;order&quot;\n  labels: \n    app: &quot;order&quot;\nspec: \n  selector: \n    matchLabels: \n      app: &quot;order&quot;\n  replicas: 1\n  template: \n    metadata: \n      labels: \n        app: &quot;order&quot;\n    spec: \n      containers: \n        - \n          name: &quot;order&quot;\n          image: &quot;jinyoung/order:database&quot;\n          ports: \n            - \n              containerPort: 80\n          env:\n            - name: superuser.userId\n              value: some_value\t\t\t\t\t\n            - name: _DATASOURCE_ADDRESS\n              value: mysql\n            - name: _DATASOURCE_TABLESPACE\n              value: orderdb\n            - name: _DATASOURCE_USERNAME\n              value: root\n            - name: _DATASOURCE_PASSWORD\n              value: admin</code></pre>\n<p>설정후에 kubectl logs 로 로그를 확인하면 다음과 같은 오류를 발견할 수 있다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get po # pod 명 확인\nkubectl logs &lt;pod 명&gt;</code></pre>\n<p>로그 내용중:</p>\n<pre class=\"language-text\"><code class=\"language-text\">Caused by: java.net.UnknownHostException: mysql: Name does not resolve</code></pre>\n<p>우리가 제공한 DB server 의 주소를 환경변수로 잘 받아왔고 (mysql), 그 주소로 접근을 시도했으나 서비스가 올라있지 않으므로 발생하는 오류이다.</p>\n<p>값을 위와 같이 Deployment 설정에 직접 입력하는것은 개발자와 운영자사이에 역할이 혼재되므로, 운영자가 해당 설정 부분만을 관리할 수 있도록 별도의 Configuration 을 위한 쿠버네티스 객체인 ConfigMap (혹은 Secret)을 선언하여 연결할 수 있다. 여기서는 패스워드가 노출되면 안되므로 PASSWORD 에 대해서만 Secret 을 이용하여 분리해준다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysql-pass\ntype: Opaque\ndata:\n  password: YWRtaW4=     </code></pre>\n<blockquote>\n<p>\"YWRtaW4=\"는  'admin' 문자열의 BASE64 인코딩된 문자열이다.   \"echo -n 'admin' | base64\" 명령을 통해 생성가능하다.</p>\n</blockquote>\n<p>Secret 객체의 내용을 기존 deployment.yaml 에 추가하고:</p>\n<pre class=\"language-text\"><code class=\"language-text\">$ kubectl apply -f deployment.yaml\n\nsecret/mysql-pass created</code></pre>\n<p>생성된 secret 을 확인한다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">$ kubectl get secrets\n\nNAME                  TYPE                                  DATA   AGE\ndefault-token-l7t7b   kubernetes.io/service-account-token   3      4h24m\nmysql-pass            Opaque                                1      1m</code></pre>\n<p>해당 Secret 을 Order Deployment 에 설정:</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">          <span class=\"token key atrule\">env</span><span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> superuser.userId\n              <span class=\"token key atrule\">value</span><span class=\"token punctuation\">:</span> userId\n            <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _DATASOURCE_ADDRESS\n              <span class=\"token key atrule\">value</span><span class=\"token punctuation\">:</span> mysql\n            <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _DATASOURCE_TABLESPACE\n              <span class=\"token key atrule\">value</span><span class=\"token punctuation\">:</span> orderdb\n            <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _DATASOURCE_USERNAME\n              <span class=\"token key atrule\">value</span><span class=\"token punctuation\">:</span> root\n            <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> _DATASOURCE_PASSWORD\n              <span class=\"token key atrule\">valueFrom</span><span class=\"token punctuation\">:</span>\n                <span class=\"token key atrule\">secretKeyRef</span><span class=\"token punctuation\">:</span>\n                  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mysql<span class=\"token punctuation\">-</span>pass\n                  <span class=\"token key atrule\">key</span><span class=\"token punctuation\">:</span> password</code></pre>\n<h2 id=\"database-서비스의-생성\"><a href=\"#database-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Database 서비스의 생성</h2>\n<p>주문 서비스를 위한 데이터베이스로 MySQL 을 사용하기로 한다. MySQL 이미지명으로 간단하게 Pod 하나를 생성한다. </p>\n<p>MySQL 을 위한 Pod 설치:</p>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: mysql\n  labels:\n    name: lbl-k8s-mysql\nspec:\n  containers:\n  - name: mysql\n    image: mysql:latest\n    env:\n    - name: MYSQL_ROOT_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: mysql-pass\n          key: password\n    ports:\n    - name: mysql\n      containerPort: 3306\n      protocol: TCP\n    volumeMounts:\n    - name: k8s-mysql-storage\n      mountPath: /var/lib/mysql\n  volumes:\n  - name: k8s-mysql-storage\n    emptyDir: {}</code></pre>\n<p>생성된 yaml 을 deployment.yaml 에 추가한후:</p>\n<pre class=\"language-text\"><code class=\"language-text\">$ kubectl apply -f deployment.yaml\n\npod/k8s-mysql created</code></pre>\n<p>Pod 실행을 확인한다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">$ kubectl get pod\n\nNAME        READY   STATUS    RESTARTS   AGE\nk8s-mysql   1/1     Running   0          30s\nNow, we can connect to the k8s-mysql pod:</code></pre>\n<p>Pod 에 접속하여 orderdb 데이터베이스 공간을 만들어주고 데이터베이스가 잘 동작하는지 확인한다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">$ kubectl exec mysql -it -- bash\n\n# echo $MYSQL_ROOT_PASSWORD\nadmin\n\n# mysql --user=root --password=$MYSQL_ROOT_PASSWORD\n\nmysql&gt; create database orderdb;\n    -&gt; ;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| orderdb            |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.01 sec)\n\nmysql&gt; exit</code></pre>\n<p>주문 마이크로 서비스를 쿠버네티스 DNS 체계내에서 접근가능하게 하기 위해 ClusterIP 로 서비스를 생성해준다. 주문 서비스에서 mysql 접근을 위하여 \"mysql\"이라는 도메인명으로 접근하고 있으므로, 같은 이름으로 서비스를 만들어준다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    name: lbl-k8s-mysql\n  name: mysql\n  namespace: default\nspec:\n  ports:\n  - port: 3306\n    protocol: TCP\n    targetPort: 3306\n  selector:\n    name: lbl-k8s-mysql\n  type: ClusterIP</code></pre>\n<blockquote>\n<p>마찬가지 위의 내용을 deployment.yaml 에 추가하고 kubectl apply -f deployment.yaml\n앞으로 계속 마찬가지!</p>\n</blockquote>\n<p>주문 마이크로 서비스만을 새로 재기동 시키기 위해서는 아래와 같이 po 를 삭제해주면 deployment 에 의해서 알아서 재시작된다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get po -l app=order\nkubectl delete po [order-po-name]</code></pre>\n<p>이렇게 잘 접속이 된다면 다음의 로그를 확인할 수 있다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">Hibernate: \n    insert \n    into\n        ProductOption\n        (description, name, optionName, PRODUCT_ID) \n    values\n        (?, ?, ?, ?)\nHibernate: \n    insert \n    into\n        Product\n        (imageUrl, name, price, stock) \n    values\n        (?, ?, ?, ?)\nHibernate: \n    insert \n    into\n        ProductOption\n        (description, name, optionName, PRODUCT_ID) \n    values\n        (?, ?, ?, ?)\nHibernate: \n    insert \n    into\n        ProductOption\n        (description, name, optionName, PRODUCT_ID) \n    values\n        (?, ?, ?, ?)</code></pre>\n<h2 id=\"주문-걸어보기\"><a href=\"#%EC%A3%BC%EB%AC%B8-%EA%B1%B8%EC%96%B4%EB%B3%B4%EA%B8%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>주문 걸어보기</h2>\n<p>httpie pod 에 들어가서 주문을 걸어준다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl exec -it httpie /bin/bash \n\nroot@httpie:/# http order:8080/orders productId=1 customerId=&quot;jjy&quot;</code></pre>\n<blockquote>\n<p>위의 'order' 도메인 주소로 접근이 되도록 하려면 order 를 위한 Service (이름 order) 객체가 꼭 만들어져 있어야 한다.</p>\n</blockquote>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: &quot;v1&quot;\nkind: &quot;Service&quot;\nmetadata: \n  name: &quot;order&quot;\n  labels: \n    app: &quot;order&quot;\nspec: \n  ports: \n    - \n      port: 8080\n      targetPort: 8080\n  selector: \n    app: &quot;order&quot;\n  type: &quot;ClusterIP&quot;</code></pre>\n<blockquote>\n<p>order 라는 도메인 주소로 호출이 되려면 order 와 같은 클러스터내부에서 호출해야 한다. 그러려면 httpie pod 를 만들어서 order 와 같은 네임스페이스 (default) 내에 httpie pod 가 생성되어있어야 한다.\nhttpie pod 를 만들기:</p>\n</blockquote>\n<pre class=\"language-text\"><code class=\"language-text\">cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: &quot;v1&quot;\nkind: &quot;Pod&quot;\nmetadata: \n  name: httpie\n  labels: \n    name: httpie\nspec: \n  containers: \n    - \n      name: httpie\n      image: clue/httpie\n      command:\n        - sleep\n        - &quot;36000&quot;\nEOF</code></pre>\n<blockquote>\n<p>httpie pod 를 만들기 귀찮다면.. kubectl port-forward deploy/order 8085:8080 를 해놓은 후, localhost:8085 번으로 호출해도 된다. </p>\n</blockquote>\n<p>주문 마이크로 서비스의 데이터가 설치한 MySQL을 통하여 보존되는 것을 확인한다. </p>\n<pre class=\"language-text\"><code class=\"language-text\">mysql&gt; use orderdb\nReading table information for completion of table and column names\nYou can turn off this feature to get a quicker startup with -A\n\nDatabase changed\nmysql&gt; show tables;\n+-------------------+\n| Tables_in_orderdb |\n+-------------------+\n| Delivery          |\n| Product           |\n| ProductOption     |\n| order_table       |\n+-------------------+\n4 rows in set (0.00 sec)\n\nmysql&gt; select * from order_table\n\n+----+--------------+------------+--------------+-------+-----------+-------------+----------+-------------+-------------+\n| id | customerAddr | customerId | customerName | price | productId | productName | quantity | state       | product_idx |\n+----+--------------+------------+--------------+-------+-----------+-------------+----------+-------------+-------------+\n|  1 | NULL         | jjy        | NULL         | 10000 |         1 | TV          |        0 | OrderPlaced |           1 |\n+----+--------------+------------+--------------+-------+-----------+-------------+----------+-------------+-------------+\n1 row in set (0.00 sec)</code></pre>\n<blockquote>\n<p>주문 마이크로 서비스를 내렸다가 올려도 주문한 내역이 그대로 존재함을 확인할 수 있어야 한다.</p>\n</blockquote>\n<h2 id=\"persistencevolume-을-통한-데이터베이스-데이터-보존\"><a href=\"#persistencevolume-%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%B4%EC%A1%B4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PersistenceVolume 을 통한 데이터베이스 데이터 보존</h2>\n<p>먼저, MySQL 서비스의 설치를 제거했다가 다시 기동시켜본다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete pod mysql\nkubectl apply -f deployment.yaml</code></pre>\n<p>애플리케이션 데이터가 소실됨을 확인할 수 있다. </p>\n<p>이는, MySQL 자체가 사용하는 볼륨이 해당 Pod 에 기본 부착된 파일시스템이기 때문이다. 이를 해결하기 위하여 PersistenceVolume 으로 된 파일시스템에 연결하도록 설정한다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">spec:\n  containers:\n    volumeMounts:\n    - name: k8s-mysql-storage\n      mountPath: /var/lib/mysql\n  volumes:\n  - name: k8s-mysql-storage\n    persistentVolumeClaim:\n      claimName: &quot;fs&quot;</code></pre>\n<p>변경후 apply 를 해주고 기다려보면 해당 Pod 는 Pending 상태에 잠기게 된다. 이유는 해당 Pod 를 위한 fs 라는 PVC가 생성되지 않았기 때문이다.</p>\n<p>우리는 저 \"fs\" 라고 하는 PVC 를 플랫폼(애져 or AWS등)의 파일 서비스에서 만들어와야 한다.</p>\n<h3 id=\"pvc-생성\"><a href=\"#pvc-%EC%83%9D%EC%84%B1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>PVC 생성</h3>\n<p>PersistentVolumeClaim - PVC 를 생성하는 방법은 간단하다. 기본으로 장착된 gp2라고 하는 StorageClass 를 통해서 얻을 수 있기 때문이다.\n아래와 같은 yaml 을 설정한 후, kubectl get pvc 를 통해 PVC가 생성되는 것을 확인한다. </p>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fs\n  labels:\n    app: test-pvc\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Mi</code></pre>\n<p>PVC가 생성되면, mysql pod 의 pending 이 해제될 것이다. </p>\n<blockquote>\n<p>Volume mount 에 대한 설정변경은 그냥 apply 만 해서는 반영이 될 수 없다는 오류가 발견될 것이다. 이를 해결하기 위해서는 완전히 기존 mysql 설정을 삭제한 후 다시 기동해주어야 한다: </p>\n</blockquote>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete -f deployment.yaml\nkubectl apply -f deployment.yaml</code></pre>\n<blockquote>\n<p>다시 기동후에는 orderdb 테이블 스페이스를 다시 만들어주어야 한다.</p>\n</blockquote>\n<p>그런후에 PVC 상태를 확인:</p>\n<pre class=\"language-text\"><code class=\"language-text\"># kubectl get pvc\nNAME            STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE\naws-ebs         Bound     pvc-225ebe47-cc67-4985-8f94-c0d4d795dede   1Gi        RWO            gp2            9m47s</code></pre>\n<p>이제, MySQL 이 소실된다하더라도, PersistenceVolume 에 실제 연결된 클라우드 파일 시스템에 데이터가 보존됨을 확인할 수 있다. </p>\n<p>주문 한건을 걸어본 후,</p>\n<p>mysql pod 를 삭제하고,</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete pod mysql\nkubectl apply -f deployment.yaml</code></pre>\n<p>그 후에도, 해당 데이터가 존재함을 확인한다.</p>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"파일시스템 (볼륨) 연결과 데이터베이스 설정","anchor":"#파일시스템-볼륨-연결과-데이터베이스-설정"},{"depth":2,"value":"주문 서비스에 Database 설정의 변경","anchor":"#주문-서비스에-database-설정의-변경"},{"depth":2,"value":"Database 서비스의 생성","anchor":"#database-서비스의-생성"},{"depth":2,"value":"주문 걸어보기","anchor":"#주문-걸어보기"},{"depth":2,"value":"PersistenceVolume 을 통한 데이터베이스 데이터 보존","anchor":"#persistencevolume-을-통한-데이터베이스-데이터-보존"},{"depth":3,"value":"PVC 생성","anchor":"#pvc-생성"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-service/","title":"12번가 마이크로서비스 라우터(Service) 적용"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-readiness/","title":"무정지 배포 실습"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Commands"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/msa-logging/","title":"MSA 로깅 with EFK Stack"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/development/keycloak-oauth2-2/","title":"Pub/Sub 방식의 연동 (New)"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/development/oauth2withkeycloak/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 (New)"}},{"node":{"path":"/development/keycloak-oauth2-3/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation (New)"}},{"node":{"path":"/development/oauth2/","title":"Req/Res 방식의 MSA 연동 (New)"}},{"node":{"path":"/development/monolith2misvc/","title":"Kafka Retry & Dead Letter Queue (New)"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/gateway/","title":"단위 마이크로 서비스의 실행 (New)"}},{"node":{"path":"/development/kafka-manual-commit/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/keycloak-oauth2-1/","title":"Kafka 기본 명령어 (New)"}},{"node":{"path":"/development/kafka-scaling/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/cna-pubsub/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/kafka-base/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/cna-pubsub2/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/front-end/","title":"Kafka Scaling (New)"}},{"node":{"path":"/development/circuitbreaker/","title":"API Gateway"}},{"node":{"path":"/business/","title":"[분석] DDD 이벤트의 도출 - 12번가 쇼핑몰"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] DDD Food Delivery 예제"}},{"node":{"path":"/development/advanced-connect/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] DDD 구글 드라이브 예제"}}]}},"context":{}}