{"hash":"06a886723e5e9e504c2e092ae07219a81ecc6278","data":{"markdownPage":{"id":"0dce85dd4a46fd82a5cd8377d73710da","title":"셀프힐링 & 무정지 배포 실습","description":"","path":"/operations/ops-readiness/","timeToRead":6,"content":"<h1 id=\"셀프힐링--무정지-배포-실습\"><a href=\"#%EC%85%80%ED%94%84%ED%9E%90%EB%A7%81--%EB%AC%B4%EC%A0%95%EC%A7%80-%EB%B0%B0%ED%8F%AC-%EC%8B%A4%EC%8A%B5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>셀프힐링 &#x26; 무정지 배포 실습</h1>\n<h1 id=\"셀프힐링--무정지-배포-실습-1\"><a href=\"#%EC%85%80%ED%94%84%ED%9E%90%EB%A7%81--%EB%AC%B4%EC%A0%95%EC%A7%80-%EB%B0%B0%ED%8F%AC-%EC%8B%A4%EC%8A%B5-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>셀프힐링 &#x26; 무정지 배포 실습</h1>\n<h2 id=\"셀프힐링-실습-livenessprobe\"><a href=\"#%EC%85%80%ED%94%84%ED%9E%90%EB%A7%81-%EC%8B%A4%EC%8A%B5-livenessprobe\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>셀프힐링 실습 (livenessProbe)</h2>\n<p>본 랩에서는 먼저 컨테이너에 장애가 생겼을 때, 컨테이너 플랫폼이 자동으로 장애를 감지하여 복구하는 내용을 실습한다. </p>\n<p>또한, 컨테이너 플랫폼이 각 마이크로서비스들의 Healthy 여부를 체크하는 Probe Action 중, Command Type과 HttpGet Type을 적용해 보고 복구 시 어떠한 변화가 있는지도 알아본다.</p>\n<h3 id=\"command-probeaction\"><a href=\"#command-probeaction\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Command ProbeAction</h3>\n<h4 id=\"command-type의-probe-action이-설정된-yaml을-배포한다\"><a href=\"#command-type%EC%9D%98-probe-action%EC%9D%B4-%EC%84%A4%EC%A0%95%EB%90%9C-yaml%EC%9D%84-%EB%B0%B0%ED%8F%AC%ED%95%9C%EB%8B%A4\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Command type의 Probe Action이 설정된 YAML을 배포한다.</h4>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    test: liveness\n  name: liveness-exec\nspec:\n  containers:\n  - name: liveness\n    image: k8s.gcr.io/busybox\n    args:\n    - /bin/sh\n    - -c\n    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600\n    livenessProbe:\n      exec:\n        command:\n        - cat\n        - /tmp/healthy\n      initialDelaySeconds: 5\n      periodSeconds: 5\nEOF\t\t\t</code></pre>\n<ul>\n<li>컨테이너가 Running 상태로 보이나, Probe Configuration에 따라 Liveness Probe 실패가 벌어진다.</li>\n<li>kubectl describe 커맨드로 Pod 이벤트의 메시지 변화를 확인한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl describe po liveness-exec</code></pre>\n<h3 id=\"httpget-probeaction\"><a href=\"#httpget-probeaction\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>HttpGet ProbeAction</h3>\n<ul>\n<li>HttpGet type의 Probe Action이 설정된  주문 마이크로서비스 배포</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f https://raw.githubusercontent.com/acmexii/demo/master/edu/order-liveness.yaml</code></pre>\n<ul>\n<li>배포된 주문서비스에 대해 라우터를 생성한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl expose deploy order --type=LoadBalancer --port=8080\nkubectl get svc</code></pre>\n<ul>\n<li>Order Liveness Probe를 명시적으로 Fail 상태로 전환한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\"># Liveness Probe 확인\nhttp EXTERNAL-IP:8080/actuator/health\n# Liveness Probe Fail 설정 및 확인\nhttp put EXTERNAL-IP:8080/actuator/down\nhttp EXTERNAL-IP:8080/actuator/health</code></pre>\n<ul>\n<li>Probe Fail에 따른 쿠버네티스 동작확인</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl get pod\nkubectl describe pod/[ORDER-POD객체]</code></pre>\n<ul>\n<li>다음 실습을 위해 생성된 객체를 삭제한다.</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl delete pod,deploy,svc --all</code></pre>\n<h2 id=\"무정지-배포-실습-readinessprobe-제로-다운타임\"><a href=\"#%EB%AC%B4%EC%A0%95%EC%A7%80-%EB%B0%B0%ED%8F%AC-%EC%8B%A4%EC%8A%B5-readinessprobe-%EC%A0%9C%EB%A1%9C-%EB%8B%A4%EC%9A%B4%ED%83%80%EC%9E%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>무정지 배포 실습 (readinessProbe, 제로 다운타임)</h2>\n<p>다음으로 클러스터에 배포시 다운타임이 존재하는지 실습을 한다. 클러스터에 배포를 할때 readinessProbe 설정이 없으면 다운타임이 존재 하게 된다. 이는 쿠버네티스에서 Ramped 배포 방식으로 무정지 배포를 시도 하지만, 서비스가 기동하는 시간이 있기 때문에 기동 시간동안에 트래픽이 유입되면 장애가 발생 할 수 있다.  </p>\n<p>배포시 다운타임의 존재 여부를 확인하기 위하여, siege 라는 부하 테스트 툴을 사용한다.<br>\n배포시작전에 부하테스트 툴을 실행하고, 배포 완료시 종료한 후, 결과값인 Availability 를 체크 하여 어느정도의 실패가 있었는지를 확인한다.</p>\n<h3 id=\"선행과정\"><a href=\"#%EC%84%A0%ED%96%89%EA%B3%BC%EC%A0%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>선행과정</h3>\n<ul>\n<li>Kafka 가 설치되어있어야 한다:</li>\n<li>Kafka는 K8s 패키지 인스톨러인 Helm으로 설치 가능하므로 Helm이 먼저 설치되어야 한다.</li>\n<li>Helm 3.x 설치(권장)</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 &gt; get_helm.sh\nchmod 700 get_helm.sh\n./get_helm.sh</code></pre>\n<ul>\n<li>Kafka 설치 (Namespace 'kafka')</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\nkubectl create ns kafka\nhelm install my-kafka bitnami/kafka --namespace kafka</code></pre>\n<ul>\n<li>GitPod > Explorer 에서 마우스 오른쪽 클릭 > New Folder > Zerodowntime 입력</li>\n<li>Lab 폴더 마우스 오른쪽 클릭 > New File > deployment.yaml 입력</li>\n<li>아래 내용 복사하여 붙여넣기</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order\n  labels:\n    app: order\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: order\n  template:\n    metadata:\n      labels:\n        app: order\n    spec:\n      containers:\n        - name: order\n          image: jinyoung/order:stable\n          ports:\n            - containerPort: 8080</code></pre>\n<ul>\n<li>주문서비스를 배포한다:</li>\n</ul>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f deployment.yaml</code></pre>\n<p>서비스 객체를 위한 yaml도 만든다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">apiVersion: &quot;v1&quot;\nkind: &quot;Service&quot;\nmetadata: \n  name: &quot;order&quot;\n  labels: \n    app: &quot;order&quot;\nspec: \n  ports: \n    - \n      port: 8080\n      targetPort: 8080\n  selector: \n    app: &quot;order&quot;\n  type: &quot;ClusterIP&quot;</code></pre>\n<p>를 붙여넣기 하여 생성한 다음,</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f service.yaml</code></pre>\n<p>로 서비스 객체를 생성한다.</p>\n<ul>\n<li>\n<p>부하 테스트 Pod 설치\n- 아래 스크립트를 terminal 에 복사하여 siege 라는 Pod 를 생성한다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t```</code></pre>\n<p>  kubectl apply -f - &#x3C;&#x3C;EOF\napiVersion: v1\nkind: Pod\nmetadata:\nname: siege\nspec:\ncontainers:\n- name: siege\nimage: apexacme/siege-nginx\nEOF</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t```\n\t- 생성된 siege Pod 안쪽에서 정상작동 확인\n\t```\n\tkubectl exec -it siege -- /bin/bash\n\tsiege -c1 -t2S -v http://order:8080/orders\n\texit\n\t```</code></pre>\n</li>\n</ul>\n<h3 id=\"1-readinessprobe-가-없는-상태에서-배포-진행\"><a href=\"#1-readinessprobe-%EA%B0%80-%EC%97%86%EB%8A%94-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-%EB%B0%B0%ED%8F%AC-%EC%A7%84%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. readinessProbe 가 없는 상태에서 배포 진행</h3>\n<p>1.1 새 버전을 배포할 준비를 한다:\ndeployment.yaml 의 이미지 정보를 아래와 같이 변경한 후 (19라인):</p>\n<pre class=\"language-text\"><code class=\"language-text\">image: jinyoung/order:canary</code></pre>\n<p>1.2 새로운 터미널을 열어서 충분한 시간만큼 부하를 준다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl exec -it siege -- /bin/bash\nsiege -c1 -t60S -v http://order:8080/orders --delay=1S</code></pre>\n<p>1.3. 배포를 반영한다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl apply -f deployment.yaml</code></pre>\n<p>1.5 siege 로그를 보면서 배포시 정지시간이 발생한것을 확인한다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">Transactions:                     82 hits\nAvailability:                  70.09 %\nElapsed time:                  59.11 secs</code></pre>\n<h3 id=\"2-readinessprobe-를-설정하고-배포-진행\"><a href=\"#2-readinessprobe-%EB%A5%BC-%EC%84%A4%EC%A0%95%ED%95%98%EA%B3%A0-%EB%B0%B0%ED%8F%AC-%EC%A7%84%ED%96%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. readinessProbe 를 설정하고 배포 진행</h3>\n<p>2.1 아래와 같이 readiness 설정을 주입한다:</p>\n<pre class=\"language-text\"><code class=\"language-text\">    spec:\n      containers:\n        - name: order\n\t\t\t\t  ...\n          readinessProbe:    # 이부분!\n            httpGet:\n              path: &#39;/orders&#39;\n              port: 8080\n            initialDelaySeconds: 10\n            timeoutSeconds: 2\n            periodSeconds: 5\n            failureThreshold: 10</code></pre>\n<p>2.2. image 명도 변경한다 (19라인):</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t\t\t\timage: jinyoung/order:stable</code></pre>\n<p>2.2 siege 터미널을 열어서 충분한 시간만큼 부하를 준다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">kubectl exec -it siege -- /bin/bash\nsiege -c1 -t60S -v http://order:8080/orders --delay=1S</code></pre>\n<p>2.3 수정된 주문 서비스를 적용하여 배포한다</p>\n<ul>\n<li>kubectl apply -f deployment.yaml</li>\n</ul>\n<p>2.5 siege 로그를 보면서 배포시 무정지로 배포된 것을 확인한다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">Transactions:                    112 hits\nAvailability:                 100.00 %\nElapsed time:                  59.58 secs</code></pre>\n<blockquote>\n<p>주의점: siege 테스트를 걸어놓은 후 배포해야 정확한 테스트가 이루어집니다. </p>\n</blockquote>\n<h3 id=\"상세설명\"><a href=\"#%EC%83%81%EC%84%B8%EC%84%A4%EB%AA%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>상세설명</h3>\n<iframe width=\"100%\" height=\"100%\" src=\"https://www.youtube.com/embed/n_A59SwsDJ0\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n","sidebar":"business","next":"","prev":"","headings":[{"depth":1,"value":"셀프힐링 & 무정지 배포 실습","anchor":"#셀프힐링--무정지-배포-실습"},{"depth":1,"value":"셀프힐링 & 무정지 배포 실습","anchor":"#셀프힐링--무정지-배포-실습-1"},{"depth":2,"value":"셀프힐링 실습 (livenessProbe)","anchor":"#셀프힐링-실습-livenessprobe"},{"depth":3,"value":"Command ProbeAction","anchor":"#command-probeaction"},{"depth":4,"value":"Command type의 Probe Action이 설정된 YAML을 배포한다.","anchor":"#command-type의-probe-action이-설정된-yaml을-배포한다"},{"depth":3,"value":"HttpGet ProbeAction","anchor":"#httpget-probeaction"},{"depth":2,"value":"무정지 배포 실습 (readinessProbe, 제로 다운타임)","anchor":"#무정지-배포-실습-readinessprobe-제로-다운타임"},{"depth":3,"value":"선행과정","anchor":"#선행과정"},{"depth":3,"value":"1. readinessProbe 가 없는 상태에서 배포 진행","anchor":"#1-readinessprobe-가-없는-상태에서-배포-진행"},{"depth":3,"value":"2. readinessProbe 를 설정하고 배포 진행","anchor":"#2-readinessprobe-를-설정하고-배포-진행"},{"depth":3,"value":"상세설명","anchor":"#상세설명"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/operations/ops-ingress/","title":"Ingress 를 통한 진입점 통일 - Path-based routing"}},{"node":{"path":"/operations/service/","title":"12번가 마이크로서비스 라우터(Service) 생성"}},{"node":{"path":"/business/","title":"[이벤트스토밍] - 12번가 쇼핑몰 예제"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] - DDD Food Delivery 예제"}},{"node":{"path":"/development/understanding-jpa-based-single-microservice/","title":"마이크로서비스 구현 및 동작원리 이해"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] - 구글 드라이브 예제"}},{"node":{"path":"/operations/ops-utility/","title":"쿠버네티스 유틸리티"}},{"node":{"path":"/operations/ops-service-mesh-istio/","title":"[Service Mesh] Istio"}},{"node":{"path":"/operations/ops-service-mesh-istio-2/","title":"[Service Mesh] Istio-2"}},{"node":{"path":"/operations/ops-readiness/","title":"셀프힐링 & 무정지 배포 실습"}},{"node":{"path":"/operations/ops-persistence-volume/","title":"파일시스템 (볼륨) 연결과 데이터베이스 설정"}},{"node":{"path":"/operations/ops-pod-status/","title":"Pod 상태값에 따른 마이크로서비스 트러블 슈팅"}},{"node":{"path":"/operations/ops-persistence-volume-efs/","title":"파일공유를 위한 NAS 스토리지 생성과 설정"}},{"node":{"path":"/operations/ops-kubernetes/","title":"Kubernetes Basic Command"}},{"node":{"path":"/operations/ops-liveness/","title":"셀프힐링 실습"}},{"node":{"path":"/operations/ops-ingress-virtualhost/","title":"Ingress - Virtual Host based"}},{"node":{"path":"/operations/ops-autoscale/","title":"Pod Auto Scaling"}},{"node":{"path":"/operations/ops-deploy-my-app/","title":"애플리케이션 패키징,도커라이징,클러스터 배포"}},{"node":{"path":"/operations/ops-argo-rollout-canary-istio/","title":"[GitOps] Argo Rollout 와 Istio 를 통한 카나리 배포"}},{"node":{"path":"/operations/ops-aws-setting/","title":"AWS Cloud Setup(EKS, ECR 설정)"}},{"node":{"path":"/operations/k8s-monitoring/","title":"MSA 모니터링 with installing Grafana"}},{"node":{"path":"/operations/ops-anatomy-kubernetes/","title":"쿠버네티스 내부구조 분석"}},{"node":{"path":"/operations/microservice-logging/","title":"마이크로서비스 통합 로깅 with EFK stack"}},{"node":{"path":"/operations/istio-resiliency-part1/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part1 - 타임아웃/재시도"}},{"node":{"path":"/operations/istio-traffic/","title":"[Service Mesh] Istio 를 통한 동적 트래픽 라우팅"}},{"node":{"path":"/operations/istio-msa-telemetry/","title":"[Service Mesh] MSA 모니터링 w/ Istio addon Grafana"}},{"node":{"path":"/operations/istio-resiliency-part2/","title":"[Service Mesh] Istio 를 통한 서비스 회복성 Part2 - 서킷브레이커"}},{"node":{"path":"/operations/istio-metric-based-hpa/","title":"[Service Mesh] Istio Metrics based HPA"}},{"node":{"path":"/operations/gitops-argo-cd/","title":"[GitOps] Argo CD 를 통한 카나리 배포"}},{"node":{"path":"/development/pubsub-idempotency/","title":"Pub/Sub 방식의 연동 - Choreography with Idempotency"}},{"node":{"path":"/operations/end-to-end/","title":"12번가 전체 마이크로서비스의 배포"}},{"node":{"path":"/operations/apply-security-to-12st-mall/","title":"12번가 Mall에 토큰인증 적용하기"}},{"node":{"path":"/operations/azure/","title":"Azure Cloud Setup (AKS, ACR 설정)"}},{"node":{"path":"/development/token-based-auth/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/pubsub-deadline/","title":"Pub/Sub 방식의 연동 - Choreography with Deadline added"}},{"node":{"path":"/development/ops-docker/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/pub-sub/","title":"Pub/Sub 방식의 연동 "}},{"node":{"path":"/development/oauth2with-keycloak/","title":"JWT Token 기반 인증 인가 - Advanced"}},{"node":{"path":"/development/monolith-2-misvc/","title":"Req/Res 방식의 MSA 연동 "}},{"node":{"path":"/development/kafka-connect/","title":"CDC(Change Data Capture) with Kafka"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Kafka Retry & Dead Letter Queue "}},{"node":{"path":"/development/kafka-scaling/","title":"Kafka Scaling "}},{"node":{"path":"/development/kafka-basic/","title":"Kafka 기본 명령어 "}},{"node":{"path":"/development/dp-graphql/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/contract-test/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/development/gateway/","title":"API Gateway"}},{"node":{"path":"/development/dp-frontend/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/dp-cqrs/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/compensation-correlation/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation"}},{"node":{"path":"/development/cna-start/","title":"단위 마이크로 서비스의 실행 "}},{"node":{"path":"/development/circuit-breaker/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 "}}]}},"context":{}}